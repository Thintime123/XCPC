## [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)

### 题意

给出一个区间 $[L, R]$，求区间内**每个数的数字和**，如 $123$ 这个数的数字和为 $1+2+3=6$。$（1 ≤ L ≤ R ≤ 10^{18}）$

### 思路

- $dp[pos][sum]$: 表示当前处理到第 $pos$ 位，数字和为 $sum$ 的所有情况的数位之和；
- $dfs(pos, s, limit, lead)$: 处理第 $pos$ 位数字，当前数字和为 $s$，`limit` 表示是否受限于上界，`lead` 表示是否允许前导零；
- $dfs$ 递归出口: $s$。


### 示例代码

```cpp
// dp[pos][sum] : pos 之前数字之和为 sum 的所有情况的数位之和
vector<vector<int>> dp(20, vector<int>(200, -1));
vector<int> num(20);

int dfs(int pos, int s, bool limit, bool lead) {
	if(pos == 0) return s;

	if(!limit && !lead && dp[pos][s] != -1) return dp[pos][s];
	int up = limit ? num[pos] : 9;
	int ans = 0;

	fer(i, 0, up + 1) {
		ans = (ans + dfs(pos - 1, s + i, limit && i == up, lead && !i)) % MOD;
	}

	if(!limit && !lead) dp[pos][s] = ans;
	return ans;
}

void solve() {
    ll l, r;
    cin >> l >> r;

    auto get = [&](ll n) -> int {
    	int len = 0;
    	dp.assign(20, vector<int> (200, -1));
    	while(n) {
    		num[++len] = n % 10;
    		n /= 10;
    	}
    	return dfs(len, 0, true, true);
    };
    cout << (get(r) - get(l - 1) + MOD) % MOD << '\n';
}
```


## [P6218 [USACO06NOV] Round Numbers S](https://www.luogu.com.cn/problem/P6218)

### 题意

如果一个正整数的二进制表示中，$0$ 的数目不小于 $1$ 的数目，那么它就被称为「圆数」。
例如，9 的二进制表示为 1001，其中有 2 个 0 与 2 个 1。因此，9 是一个「圆数」。
计算区间 $[l,r]$ 中有多少个「圆数」。

### 思路

- $dp[pos][cnt0][cnt1]$: 表示当前处理到第 $pos$ 位，$0$ 的个数为 $cnt0$，$1$ 的个数为 $cnt1$ 的所有情况的满足条件的数字个数；
- $dfs(pos, cnt0, cnt1, limit, lead)$: 处理第 $pos$ 位数字，当前 $0$ 的个数为 $cnt0$，$1$ 的个数为 $cnt1$，`limit` 表示是否受限于上界，`lead` 表示是否处于前导零状态；
- 注意： 处于前导零状态时的 $0$ 不能计入 $cnt0$ 。

### 示例代码

```cpp
// dp[pos][cnt0][cnt1]
int dp[40][40][40];
vector<int> num(40);

int dfs(int pos, int cnt0, int cnt1, bool limit, bool lead) {
	if(pos == 0) return lead || cnt0 >= cnt1;

	if(!limit && !lead && ~dp[pos][cnt0][cnt1]) return dp[pos][cnt0][cnt1];

	int up = limit ? num[pos] : 1;
	int ans = 0;

	fer(i, 0, up + 1) {
		int new_lead = lead && !i;
		ans += dfs(pos - 1, cnt0 + (!new_lead && !i), cnt1 + i, limit && i == up, new_lead);
	}

	if(!limit && !lead) dp[pos][cnt0][cnt1] = ans;
	return ans;
}

signed main() {
    IOS;

    int l, r;
    cin >> l >> r;

    auto get = [&](int n) -> int {
    	int len = 0;
    	memset(dp, -1, sizeof dp);
    	while(n) {
    		num[++len] = n & 1;
    		n >>= 1;
    	}
    	return dfs(len, 0, 0, true, true);
    };

    cout << get(r) - get(l - 1) << '\n';

    return 0;
}
```
