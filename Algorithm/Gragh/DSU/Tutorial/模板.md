## 模板一

能解决的问题：

- 判断连通性：
	- `find`方法
- 计算有多少个连通块
	- 将所有节点的根放入`set`
- 环检测：
	- 判断是否有环：
		- 如果 $x,y$ 原本就在同一个集合，后续又有连接 $x,y$ 的边，那么就会成环
	- 计算环的个数：
		- 环 = 边 + 1 - 点
- 查询集合大小

```cpp
struct DSU {
	int n;
	vector<int> fa, rank;
	vector<int> sz;

	// 节点编号从 1 开始
	DSU(int n) : n(n) {
		fa.resize(n + 1);
		iota(all(fa), 0);
		rank.resize(n + 1);
		sz.resize(n + 1, 1);
	}

	int find(int x) {
		return x == fa[x] ? x : fa[x] = find(fa[x]);
	}

	void merge(int x, int y) {
		int rx = find(x), ry = find(y);
		if(rx != ry) {
			if(sz[rx] < sz[ry]) swap(rx, ry);
			fa[ry] = rx;
			sz[rx] += sz[ry];
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size(int x) {
		return sz[find(x)];
	}
};
```