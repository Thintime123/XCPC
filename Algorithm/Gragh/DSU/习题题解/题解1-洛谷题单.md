
## [修复公路](https://www.luogu.com.cn/problem/P1111 "修复公路")

### 题意

给出村庄数 N，和公路数 M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。

### 思路

普通并查集的模板题，加上`size` 判断最大集合大小是否为 `n`

### 示例代码

```cpp
struct DSU {
	int n;
	vector<int> fa, rank;
	vector<int> sz;

	// 节点编号从 1 开始
	DSU(int n) : n(n) {
		fa.resize(n + 1);
		iota(all(fa), 0);
		rank.resize(n + 1);
		sz.resize(n + 1, 1);
	}

	int find(int x) {
		return x == fa[x] ? x : fa[x] = find(fa[x]);
	}

	void merge(int x, int y) {
		int rx = find(x), ry = find(y);
		if(rx != ry) {
			if(sz[rx] < sz[ry]) swap(rx, ry);
			fa[ry] = rx;
			sz[rx] += sz[ry];
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size(int x) {
		return sz[find(x)];
	}

	bool ok() {
		return *max_element(all(sz)) == n;
	}
};

signed main() {
    IOS;

    int n, m;
    cin >> n >> m;
    DSU uf(n);

    vector<array<int, 3>> arr(m);
    fer(i, 0, m) cin >> arr[i][1] >> arr[i][2] >> arr[i][0];

    sort(all(arr));

    for(auto &[t, a, b] : arr) {
    	uf.merge(a, b);
    	if(uf.ok()) {
    		cout << t << '\n';
    		return 0;
    	}
    }
    cout << -1 << '\n';
    return 0;
}
```

## [一中校运会之百米跑](https://www.luogu.com.cn/problem/P2256 "一中校运会之百米跑")

### 题意

有 N 个选手的名字。和 $M（1≤M≤106）$句话，即告诉你学生 A 与学生 B 在同一个组里。会问你 $K（1≤K≤106）$句话，即学生 X 和学生 Y 是否在同一组里。若是则输出 `Yes.`，否则输出 `No.`。

### 思路

是一个变式，变式在于每个节点不是数字，而是字符串。有两种处理方法：

1. 使用 `map` 进行映射
	- `map<string, string> fa` 来表示一个节点的根
	- 所以对 `int` 型节点的操作都变为 `string` 
	- 见示例代码1
2. 给每个 `string` 分配一个 `id` 编号，从而继续使用 `DSU` 模板
	- 用 `map<string, int>` 判断每个 `string` 是否分配编号，和存储 `string` 和 `id` 的映射
	- 如果需要反向根据 `id` 查找 `string` 的话可以用另外用一个 `map<int, string>` 来存储反响映射关系
	- 见示例代码2

### 示例代码1

```cpp
struct DSU {
	int n;
	map<string, string> fa;
	map<string, int> sz;

	// 节点编号从 1 开始
	DSU(int n) : n(n) {
		
	}

	string find(string x) {
		return x == fa[x] ? x : fa[x] = find(fa[x]);
	}
	void merge(string x, string y) {
		string rx = find(x), ry = find(y);
		if(rx != ry) {
			if(sz[rx] < sz[ry]) swap(rx, ry);
			fa[ry] = rx;
			sz[rx] += sz[ry];
		}
	}

	bool same(string x, string y) {
		return find(x) == find(y);
	}

	int size(string x) {
		return sz[find(x)];
	}
};

signed main() {
    IOS;

    int n, m;
    cin >> n >> m;
    DSU uf(n);

    fer(i, 0, n) {
    	string name;
    	cin >> name;
    	uf.fa[name] = name;
    }

    while(m--) {
    	string a, b;
    	cin >> a >> b;
    	uf.merge(a, b);
    }

    int k;
    cin >> k;
    while(k--) {
    	string a, b;
    	cin >> a >> b;
    	cout << (uf.same(a, b) ? "Yes." : "No.") << '\n';
    }

    return 0;
}
```

### 示例代码2

```cpp
struct DSU {
	int n;
	vector<int> fa, rank;
	vector<int> sz;

	// 节点编号从 1 开始
	DSU(int n) : n(n) {
		fa.resize(n + 1);
		iota(all(fa), 0);
		rank.resize(n + 1);
		sz.resize(n + 1, 1);
	}

	int find(int x) {
		return x == fa[x] ? x : fa[x] = find(fa[x]);
	}

	void merge(int x, int y) {
		int rx = find(x), ry = find(y);
		if(rx != ry) {
			if(sz[rx] < sz[ry]) swap(rx, ry);
			fa[ry] = rx;
			sz[rx] += sz[ry];
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size(int x) {
		return sz[find(x)];
	}
};

signed main() {
    IOS;

    int n, m;
    cin >> n >> m;

    DSU uf(n);
    int cnt = 0;
    map<string, int> mp;

    fer(i, 0, n) {
    	string name;
    	cin >> name;
    	if(!mp[name]) {
    		mp[name] = ++cnt;
    	}
    }

    while(m--) {
    	string a, b;
    	cin >> a >> b;
    	int id1 = mp[a], id2 = mp[b];
    	uf.merge(id1, id2);
    }

    int k;
    cin >> k;
    while(k--) {
    	string a, b;
    	cin >> a >> b;
    	int id1 = mp[a], id2 = mp[b];
    	cout << (uf.same(id1, id2) ? "Yes." : "No.") << '\n';
    }

    return 0;
}
```

